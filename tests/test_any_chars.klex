// Test for any character patterns
use regex::Regex;
use std::collections::HashMap;

%%
// Test whitespace for separation (must come before wildcard patterns)
/[ \t]+/ -> Whitespace

// Test specific characters to avoid conflicts
'@' -> AtSymbol
'!' -> Exclamation

// Test new any character patterns (must come last due to greedy matching)
? -> AnyChar
?+ -> AnyCharPlus
%%
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_any_char_patterns() {
        // Test with characters that won't conflict with other patterns
        let input = "$ ###".to_string();
        let mut lexer = Lexer::new(input);
        
        // Debug: print what tokens we get
        let mut tokens = Vec::new();
        while let Some(token) = lexer.next_token() {
            println!("Token: kind={:?}, value='{}'", token.kind, token.value);
            tokens.push(token);
        }
        
        // Find specific tokens
        assert!(tokens.iter().any(|t| t.kind == TokenKind::AnyChar && t.value == "$"));
        assert!(tokens.iter().any(|t| t.kind == TokenKind::Whitespace && t.value == " "));
        // AnyCharPlus might match the first '#' or all "###" depending on implementation
        assert!(tokens.iter().any(|t| t.kind == TokenKind::AnyChar && t.value == "#") || 
                tokens.iter().any(|t| t.kind == TokenKind::AnyCharPlus && t.value == "###"));
    }
}