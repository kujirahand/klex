// Test lexer with context-dependent rules

%%
[a-zA-Z_][a-zA-Z0-9_]* -> IDENTIFIER
[0-9]+ -> NUMBER
\+ -> PLUS
\- -> MINUS
[ \t]+ -> WHITESPACE
\n -> NEWLINE
%IDENTIFIER [0-9]+ -> INDEXED_NUMBER
%PLUS [0-9]+ -> POSITIVE_NUMBER
%%
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_context_dependent_lexer() {
        let input = "var 123 +456 -789".to_string();
        let mut lexer = Lexer::new(input);
        
        // First token: IDENTIFIER
        let token = lexer.next_token().unwrap();
        assert_eq!(token.kind, IDENTIFIER);
        assert_eq!(token.value, "var");
        
        // Second token: WHITESPACE
        let token = lexer.next_token().unwrap();
        assert_eq!(token.kind, WHITESPACE);
        
        // Third token: INDEXED_NUMBER (context-dependent after IDENTIFIER)
        let token = lexer.next_token().unwrap();
        assert_eq!(token.kind, INDEXED_NUMBER);
        assert_eq!(token.value, "123");
        
        // Fourth token: WHITESPACE
        let token = lexer.next_token().unwrap();
        assert_eq!(token.kind, WHITESPACE);
        
        // Fifth token: PLUS
        let token = lexer.next_token().unwrap();
        assert_eq!(token.kind, PLUS);
        assert_eq!(token.value, "+");
        
        // Sixth token: POSITIVE_NUMBER (context-dependent after PLUS)
        let token = lexer.next_token().unwrap();
        assert_eq!(token.kind, POSITIVE_NUMBER);
        assert_eq!(token.value, "456");
    }
}